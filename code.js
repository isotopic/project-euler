/**
* Isotopic - Soluções abstraídas para as questões do projeto euler
* https://projecteuler.net
*/

console.log('\033c');


/*

Scape sequences para terminal coloridinho

*/
GREEN_BOLD="\033[1;32m";
YELLOW="\033[0;33m";
YELLOW_BOLD="\033[0;33m";
MAGENTA="\033[0;35m";
MAGENTA_BOLD="\033[1;35m";
CYAN="\033[0;36m";
CYAN_BOLD="\033[1;36m";
WHITE="\033[0;37m";
WHITE_BOLD="\033[1;37m";
RED="\033[0;31m";
RED_BOLD="\033[1;31m";
BOLD="\033[1;0m";
RESET="\033[0m";



/*

As funções são referenciadas em solutions[] para que sejam acessadas interativamente pelo terminal.
São inseridos além da função, o id, descrição e valor pedido pela questão correspondente no projeto euler.

*/
var solutions = [];

function addSolution(id, func, asked, desc){
	solutions[id] = {
		func: func,
		name: func.name,
		params: functionParams(func),
		asked: asked,
		desc: desc
	}
}

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
function functionParams(func) {
  var fnStr = func.toString().replace(STRIP_COMMENTS, '');
  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
  if(result === null)
     result = [];
  return result;
}

















/*

[PROBLEM 1]

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.


SOLUÇÃO

Itera pelos números naturais sucessivamente até o limite n pedido (1000), adicionando a (sum) os valores que forem múltiplos de 3 e 5.

*/
function sum_of_multiples_3_and_5_below(n){
	var sum = 0;
	for(var a=0; a<n; a++){
		if( a%3==0 || a%5==0 ){
			sum+=a;
		}
	}
	return sum;
}

addSolution(1, sum_of_multiples_3_and_5_below, 1000, 'Função para obter a soma dos múltiplos de 3 e 5 menores que '+GREEN_BOLD+'n'+RESET+'.');







/*

[PROBLEM 2]

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


SOLUÇÃO

Percorre sequência fibonacci até o limite n pedido (4000000), incrementando (sum). 
Cada valor da sequência (next) é composto pela soma (ultimate + penultimate).
Em cada iteração, se o número fibonacci (next) é par, incrementa (sum).

*/
function sum_of_even_fibonaccis_smaller_than(n){
	var penultimate = 0;
	var ultimate = 1;
	var next = 0;
	var sum = 0;
	while(next<n){
		if(next%2==0) sum+=next;
		next = ultimate + penultimate;
		penultimate = ultimate;
		ultimate = next;
	}
	return sum;
}

addSolution(2, sum_of_even_fibonaccis_smaller_than, 4000000, 'Função para obter a soma dos elementos pares da sequência fibonacci menores que '+GREEN_BOLD+'n'+RESET+'.');







/*

[PROBLEM 3]

The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?


SOLUÇÃO

Sucessivamente tenta dividir (n) por números primos (p).
Quando é divisível, adiciona o fator primo (p) ao array factors.
(n) permanece constante para limitar os fatores primos possíveis.
(dividendo) é a cópia de (n) que vai sendo dividida até chegar a 1 (menor fator primo)

*/
function prime_factors(n){
	var factors = [];
	var dividendo=n;
	for(var p=1; p<=n; p++){
		if(dividendo%p==0){
			factors.push(p);
			dividendo=(dividendo/p);
			p=1;
		}
		if(dividendo<2) return factors;
	}

}
addSolution(3, prime_factors, 600851475143, 'Função para obter o maior fator primo do número '+GREEN_BOLD+'n'+WHITE+'\nObs.: A função retorna todos os fatores - considerar o último valor.');








/*

[PROBLEM 4]

A palindromic number reads the same both ways.
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
Find the largest palindrome made from the product of two 3-digit numbers.


SOLUÇÃO

Encontra-se o maior fator possível (max_factor) com os dígitos fornecidos (se 2 dígitos 99, se 3 dígitos 999).
Encontra-se o menor fator possível (min_factor) com os dígitos fornecidos (se 2 dígitos 10, se 3 dígitos 100).
Sucessivamente multiplica-se um pelo outro pelas combinações possíveis.


*/
function biggest_palindrome_product_of_two_numbers_with(n){

	if(n>3){
		return 'Resolução ainda não foi otimizada para n > 3.';
	}

	var max_factor = Math.pow(10,n)-1;
	var min_factor = Math.pow(10,n-1);

	var biggest = 0;
	for(var a=max_factor; a>=min_factor; a--){

		for(var b=max_factor; b>=min_factor; b--){
			prod = a*b;
			if(prod.toString().split("").reverse("").join("") == prod){
				if(prod > biggest){
					biggest = prod;
				}			
			}
		}

	}
	return biggest;

}

addSolution(4, biggest_palindrome_product_of_two_numbers_with, 3, 'Função para obter o maior palíndromo formado pelo produto de dois números de '+GREEN_BOLD+'n'+RESET+' dígitos.'); 











/*

[PROBLEM 5]

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?


SOLUÇÃO

Força bruta nesse caso (percorrer de 1 a trocentos testando os n multiplos) é inviável.
A solução é construir o número N a partir da decomposição dos divisores desejados.
Considerando o exemplo dado no enunciado (n=10), para N ser o menor possível e divisível por 1,2,3,4,5,6,7,8,9 e 10, é necessário que:
N / (1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10)

O problema 3 mostra que todo número pode ser fatorado em números primos.
Primeiro fatora-se todos os divisores em primos (usando a função do problema 3).
Armazena-se as maiores potências possíveis de cada divisor fatorado.
N / [ 1 . 2 . 3 . (2.2) . 5 . (2.3) . 7 . (2.2.2) . (3.3) . (2.5) ] = 1

Para cada divisor, basta considerar apenas os que formaram a maior potência de cada primo:
1 . 2ˆ3 . 3ˆ2 . 5 . 7 = 2520

*/
function smallest_number_divisible_by_1_to(n){

	//Array para armazenar as potências de cada fator primo que compõe um divisor.
	//Os índices do array são os próprios números primos. Indices comuns ficam anulados.
	//Ex. Se biggest_powers = [0,0,3,1,null,2] então os fatores são (2*2*2) (3) (5*5).
	var biggest_powers = []; 

	//Armazena fatores de cada divisor para cálculo
	var factors;

	//Para contagem das potências de cada fator primo
	var power_count;

	//Loop pelos divisores desejados (por ex. 1 a 10, ou 1 a 20)
	for(var divisor=2; divisor<=n; divisor++){

		factors = prime_factors(divisor);

		//console.log(divisor + ' = '+factors);

		power_count = [];

		//Loop pelos fatores desse divisor, contando ocorrências de cada primo (ou seja, potência)
		for(var f=0; f<factors.length; f++){
			if(factors[f]!=null){
				power_count[factors[f]] = ( power_count[factors[f]] || 0 );
				power_count[factors[f]]++;		
			}
		}

		//Com a contagem das potências, atualiza biggest_powers caso encontre uma potência maior para determinado primo
		for(var p=1; p<power_count.length; p++){
			biggest_powers[p] = (biggest_powers[p] || 0);
			if(power_count[p] != null && power_count[p] > biggest_powers[p]){
				biggest_powers[p] = power_count[p];
			}
		}

	}

	//Multiplica todos os fatores para descobrir o número
	var prod = 1;
	for(var i=1; i<biggest_powers.length; i++){
		power = (biggest_powers[i]||0);
		//console.log(i+'^'+power);
		prod *= Math.pow(i,power);
	}

	return prod;
}

addSolution(5, smallest_number_divisible_by_1_to, 20, 'Função para obter o menor número que seja divisível por todos os inteiros de 1 a '+GREEN_BOLD+'n'+RESET+'.'); 













/*

[PROBLEM 6]

The sum of the squares of the first ten natural numbers is,
12 + 22 + ... + 102 = 385

The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)2 = 552 = 3025

Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.


SOLUÇÃO

Sem graça comparado ao anterior. COMBO BREAKER

*/
function diff_between_sum_of_squares_and_square_of_sum_of_1_to(n){
	var square_of_sum = 0;
	var sum_of_squares = 0;

	for(var a=1; a<=n; a++){
		square_of_sum += a;
		sum_of_squares += a*a;
	}

	square_of_sum *= square_of_sum;

	return square_of_sum - sum_of_squares;
}

addSolution(6, diff_between_sum_of_squares_and_square_of_sum_of_1_to, 100, 'Função para obter a diferença entre o [quadrado da soma de 1 a '+GREEN_BOLD+'n'+WHITE+'] e a [soma dos quadrados de 1 a '+GREEN_BOLD+'n'+WHITE+'].'+RESET);


/*
var res = diff_between_sum_of_squares_and_square_of_sum_of_1_to(1000);
console.log(res);
process.exit();
*/










































































/*

CLI

Interface da linha de comando para exibir as soluções interativamente e permitir executá-las com outros parâmetros além do perguntado.

*/




var readline = require('readline');
var rl;


function getSolved(){
	var solved = [];
	for(var a=0; a<solutions.length; a++){
		if(solutions[a]!=null){
			solved.push(a);
		};
	}
	return solved;
}



function startCLI(){
	banner = WHITE;
	banner += "---------------------------------------------------\n";
	banner += ",--.                ,--.                ,--.       \n";
	banner += "|  | ,---.  ,---. ,-'  '-. ,---.  ,---. `--' ,---. \n";
	banner += "|  |(  .-' | .-. |'-.  .-'| .-. || .-. |,--.| .--' \n";
	banner += "|  |.-'  `)' '-' '  |  |  ' '-' '| '-' '|  |\ `--. \n";
	banner += "`--'`----'  `---'   `--'   `---' |  |-' `--' `---' \n";
	banner += "                                 `--'              \n";
	banner += "                 Abstracted Project Euler solutions\n";
	banner += "---------------------------------------------------\n";
	//banner = "";

    console.log(banner);

    var solved = getSolved();
    console.log('\nResoluções disponíveis até o momento: '+WHITE_BOLD+'['+solved.join(', ')+ ']'+RESET)
	
	rl = readline.createInterface({
	  input: process.stdin,
	  output: process.stdout
	});

	chooseProblem();
}




function chooseProblem(){
	rl.question('\n  >  Digite o id de uma questão, ou x para sair: ', function(id) {
		if(id=='x'||id=='X'){
			console.log('');
			rl.close();
			return;
		}
		if(!isNaN(id) && solutions[id]!=null){
			chooseParams(id);
		}else{
			console.log(WHITE+'\nId de questão inválido.'+RESET);
			chooseProblem();
		}
	});
}





function chooseParams(id){
	console.log('\n'+WHITE+'PROBLEMA '+id+':\n'+solutions[id].desc+RESET);
	if(solutions[id].params.length==0){
		solveProblem(id);
	}else{
		rl.question('\n  >  Digite um valor para '+WHITE_BOLD+solutions[id].params[0]+RESET+' (o enunciado pede '+solutions[id].params[0]+' = '+solutions[id].asked+'): ', function(param) {
			solveProblem(id, param);
		});
	}

}




function solveProblem(id, param){
	var response = "";
	if(!param){
		response = solutions[id].func();
	}else{
		response = solutions[id].func(param);
	}
	console.log('\n'+WHITE_BOLD+response+RESET);
	chooseProblem();
}










startCLI();




















